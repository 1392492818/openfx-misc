--- CImg.h.orig	2016-05-09 19:01:40.000000000 +0200
+++ CImg.h	2016-05-09 19:22:27.000000000 +0200
@@ -29506,10 +29506,12 @@
           mx2 = mask.width()/2, my2 = mask.height()/2, mz2 = mask.depth()/2,
           mx1 = mx2 - 1 + (mask.width()%2), my1 = my2 - 1 + (mask.height()%2), mz1 = mz2 - 1 + (mask.depth()%2),
           mxe = width() - mx2, mye = height() - my2, mze = depth() - mz2;
+        bool go = true;
 #ifdef cimg_use_openmp
 #pragma omp parallel for cimg_openmp_if(res._spectrum>=2)
 #endif
         cimg_forC(res,c) {
+          if (go) { try {
           cimg_test_abort();
           const CImg<T> _img = get_shared_channel(c%_spectrum);
           const CImg<t> _mask = mask.get_shared_channel(c%mask._spectrum);
@@ -29623,6 +29625,12 @@
                 }
               }
           }
+          } catch (...) {
+#ifdef cimg_use_opemp
+#pragma omp atomic
+#endif
+            go &= false;
+          } }
         }
       }
       return res;
@@ -29753,10 +29761,12 @@
         mx2 = mask.width()/2, my2 = mask.height()/2, mz2 = mask.depth()/2,
         mx1 = mx2 - 1 + (mask.width()%2), my1 = my2 - 1 + (mask.height()%2), mz1 = mz2 - 1 + (mask.depth()%2),
         mxe = width() - mx2, mye = height() - my2, mze = depth() - mz2;
+      bool go = true;
 #ifdef cimg_use_openmp
 #pragma omp parallel for cimg_openmp_if(_spectrum>=2)
 #endif
       cimg_forC(*this,c) {
+        if (go) { try {
         cimg_test_abort();
         const CImg<T> _img = get_shared_channel(c%_spectrum);
         const CImg<t> _mask = mask.get_shared_channel(c%mask._spectrum);
@@ -29869,7 +29879,12 @@
               }
             }
         }
-      }
+      } catch (...) {
+#ifdef cimg_use_opemp
+#pragma omp atomic
+#endif
+        go &= false;
+      } } }
       return res;
     }
 
@@ -30055,10 +30070,12 @@
         mx2 = mask.width()/2, my2 = mask.height()/2, mz2 = mask.depth()/2,
         mx1 = mx2 - 1 + (mask.width()%2), my1 = my2 - 1 + (mask.height()%2), mz1 = mz2 - 1 + (mask.depth()%2),
         mxe = width() - mx2, mye = height() - my2, mze = depth() - mz2;
+      bool go = true;
 #ifdef cimg_use_openmp
 #pragma omp parallel for cimg_openmp_if(_spectrum>=2)
 #endif
       cimg_forC(*this,c) {
+        if (go) { try {
         cimg_test_abort();
         const CImg<T> _img = get_shared_channel(c%_spectrum);
         const CImg<t> _mask = mask.get_shared_channel(c%mask._spectrum);
@@ -30170,7 +30187,12 @@
               }
             }
         }
-      }
+      } catch (...) {
+#ifdef cimg_use_opemp
+#pragma omp atomic
+#endif
+        go &= false;
+      } } }
       return res;
     }
 
@@ -30182,6 +30204,7 @@
     **/
     CImg<T>& dilate(const unsigned int sx, const unsigned int sy, const unsigned int sz=1) {
       if (is_empty() || (sx==1 && sy==1 && sz==1)) return *this;
+      bool go = true;
       if (sx>1 && _width>1) { // Along X-axis.
         const int L = width(), off = 1, s = (int)sx, _s2 = s/2 + 1, _s1 = s - _s2, s1 = _s1>L?L:_s1, s2 = _s2>L?L:_s2;
         CImg<T> buf(L);
@@ -30189,6 +30212,7 @@
 #pragma omp parallel for collapse(3) firstprivate(buf) if (size()>524288)
 #endif
         cimg_forYZC(*this,y,z,c) {
+          if (go) { try {
           T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
           const T *const ptrsb = data(0,y,z,c), *ptrs = ptrsb, *const ptrse = ptrs + L*off - off;
           T cur = *ptrs; ptrs+=off; bool is_first = true;
@@ -30222,6 +30246,12 @@
             }
             T *pd = data(0,y,z,c); cimg_for(buf,ps,T) { *pd = *ps; pd+=off; }
           }
+          } catch (...) {
+#ifdef cimg_use_opemp
+#pragma omp atomic
+#endif
+            go &= false;
+          } }
         }
       }
 
@@ -30233,6 +30263,7 @@
 #pragma omp parallel for collapse(3) firstprivate(buf) if (size()>524288)
 #endif
         cimg_forXZC(*this,x,z,c) {
+          if (go) { try {
           T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
           const T *const ptrsb = data(x,0,z,c), *ptrs = ptrsb, *const ptrse = ptrs + L*off - off;
           T cur = *ptrs; ptrs+=off; bool is_first = true;
@@ -30266,6 +30297,12 @@
             }
             T *pd = data(x,0,z,c); cimg_for(buf,ps,T) { *pd = *ps; pd+=off; }
           }
+          } catch (...) {
+#ifdef cimg_use_opemp
+#pragma omp atomic
+#endif
+            go &= false;
+          } }
         }
       }
 
@@ -30277,6 +30314,7 @@
 #pragma omp parallel for collapse(3) firstprivate(buf) if (size()>524288)
 #endif
         cimg_forXYC(*this,x,y,c) {
+          if (go) { try {
           T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
           const T *const ptrsb = data(x,y,0,c), *ptrs = ptrsb, *const ptrse = ptrs + L*off - off;
           T cur = *ptrs; ptrs+=off; bool is_first = true;
@@ -30310,6 +30348,12 @@
             }
             T *pd = data(x,y,0,c); cimg_for(buf,ps,T) { *pd = *ps; pd+=off; }
           }
+          } catch (...) {
+#ifdef cimg_use_opemp
+#pragma omp atomic
+#endif
+            go &= false;
+          } }
         }
       }
       return *this;
